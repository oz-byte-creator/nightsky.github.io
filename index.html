<!DOCTYPE html>
<html lang="en" />
<head>
  <meta charset="UTF-8" />
  <title>Persistent Starry Lines</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #0b1d51, #000011);
    }

    canvas {
      display: block;
      filter: drop-shadow(0 0 6px #fffacd);
      background: transparent;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    function resizeCanvas() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      origin.x = width / 2;
      origin.y = height / 2;
    }
    window.addEventListener('resize', resizeCanvas);

    // Settings
    const LINE_LENGTH = 50;
    const MAX_DEPTH = 10;
    const SPEED = 5;

    const origin = { x: 0, y: 0 };

    // Stars for background
    const stars = [];
    const STAR_COUNT = 150;

    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random() * width,
          y: Math.random() * height,
          radius: Math.random() * 1.2 + 0.3,
          alpha: Math.random(),
          delta: (Math.random() * 0.02) + 0.005,
        });
      }
    }

    function drawStars() {
      for (const star of stars) {
        star.alpha += star.delta;
        if (star.alpha > 1) {
          star.alpha = 1;
          star.delta *= -1;
        } else if (star.alpha < 0.2) {
          star.alpha = 0.2;
          star.delta *= -1;
        }
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 255, 200, ${star.alpha})`;
        ctx.shadowColor = 'rgba(255, 255, 200, 0.9)';
        ctx.shadowBlur = 6;
        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // Possible directions only horizontal or vertical
    const directions = ['up', 'down', 'left', 'right'];

    // Animation state
    let path = []; // stores finished lines
    let currentLine = null;
    let depth = 0;

    function drawDot(x, y, size = 5) {
      ctx.fillStyle = '#fffacd';
      ctx.shadowColor = '#fffacd';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawPartialLine(from, to, progress) {
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const px = from.x + dx * progress;
      const py = from.y + dy * progress;

      ctx.strokeStyle = '#fffacd';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#fffacd';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(px, py);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawLine(from, to) {
      ctx.strokeStyle = '#fffacd';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#fffacd';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function getNextPoint(x, y, direction) {
      switch (direction) {
        case 'up':
          return { x: x, y: y - LINE_LENGTH };
        case 'down':
          return { x: x, y: y + LINE_LENGTH };
        case 'left':
          return { x: x - LINE_LENGTH, y: y };
        case 'right':
          return { x: x + LINE_LENGTH, y: y };
      }
    }

    // Reset animation
    function reset() {
      ctx.clearRect(0, 0, width, height);
      path = [];
      depth = 0;
      currentLine = null;

      drawDot(origin.x, origin.y);
      createNextLine(origin);
    }

    function createNextLine(fromPoint) {
      if (depth >= MAX_DEPTH) {
        // Pause and restart after delay
        setTimeout(() => {
          reset();
        }, 1500);
        return;
      }

      // Random direction, horizontal or vertical
      const axis = Math.random() < 0.5 ? 'horizontal' : 'vertical';
      let dir;

      if (axis === 'horizontal') {
        dir = Math.random() < 0.5 ? 'left' : 'right';
      } else {
        dir = Math.random() < 0.5 ? 'up' : 'down';
      }

      const to = getNextPoint(fromPoint.x, fromPoint.y, dir);

      currentLine = {
        from: fromPoint,
        to,
        progress: 0,
      };
      depth++;
    }

    function animate() {
      // Clear only stars and background, NOT lines
      ctx.clearRect(0, 0, width, height);

      drawStars();

      // Draw all finished lines
      for (const line of path) {
        drawLine(line.from, line.to);
        drawDot(line.to.x, line.to.y, 4);
      }

      // Draw origin dot on top
      drawDot(origin.x, origin.y);

      if (currentLine) {
        currentLine.progress += SPEED / LINE_LENGTH;

        if (currentLine.progress >= 1) {
          currentLine.progress = 1;
          // Add completed line to path
          path.push({ from: currentLine.from, to: currentLine.to });
          drawLine(currentLine.from, currentLine.to);
          drawDot(currentLine.to.x, currentLine.to.y, 4);

          createNextLine(currentLine.to);
          currentLine = null;
        } else {
          drawPartialLine(currentLine.from, currentLine.to, currentLine.progress);
        }
      }

      requestAnimationFrame(animate);
    }

    // Init
    resizeCanvas();
    initStars();
    reset();
    animate();
  </script>
</body>
</html>
